# GoatDB — Full Documentation (llms-full.txt)

> **Generated:** 2025‑04‑20
>
> This file aggregates GoatDB’s entire public documentation into one machine‑readable Markdown file, following the `/llms-full.txt` convention so language models and other tools can ingest it with a single fetch.

---

## Table of Contents

1. [Installation](#installation)
2. [Concepts](#concepts)
3. [Commit Graph](#commit-graph)
4. [Conflict Resolution](#conflict-resolution)
5. [Synchronization Protocol](#synchronization-protocol)
6. [Sessions and Users](#sessions-and-users)
7. [Authorization](#authorization)
8. [Schema](#schema)
9. [Real‑Time Query Mechanism](#real-time-query-mechanism)
10. [React Hooks](#goatdb-react-hooks)
11. [Tutorial](#building-a-todo-list-app-with-goatdb)
12. [FAQ](#goatdb-faq)

---

## Installation

### GoatDB Installation

GoatDB can be installed in both **Deno** and **Node.js** environments. Deno is our preferred runtime (with benefits like compiling to a self‑contained executable), while Node.js support is currently **experimental**.

#### Deno Installation (Recommended)

1. **Add GoatDB to your project:**

   ```bash
   deno add jsr:@goatdb/goatdb
   ```

2. **Initialize the React Scaffold** (optional, for SPAs only):

   ```bash
   deno run -A jsr:@goatdb/goatdb/init
   ```
   *Note*: This installs React dependencies and creates a project scaffold with both client‑side and server‑side code. Skip if you already have a setup.

#### Node.js Installation (Experimental)

**WARNING:** Node.js support is work‑in‑progress and not production‑ready. Progress is tracked in [GitHub #27](https://github.com/goatplatform/goatdb/issues/27).

Install via npm, yarn, or pnpm:

```bash
npx jsr add @goatdb/goatdb      # npm

yarn dlx jsr add @goatdb/goatdb  # yarn

pnpm dlx jsr add @goatdb/goatdb  # pnpm
```

---

## Concepts

GoatDB is a distributed, schema‑based database designed for collaborative applications that must work both online *and* offline.

### The Data Registry

The `DataRegistry` provides a shared definition of data between all nodes—schemas, versions, and authorization rules. Most apps use `DataRegistry.default`.

### Data Model

* **Item** — atomic unit of data with its own distributed commit graph.
* **Schema** — defines structure, validation, defaults, and conflict resolution; versioned for migrations.
* **Repository** — collection of items synced independently, identified by path `/type/repo/item`.

### Repository Types

* **sys** — system repositories (`/sys/sessions`, `/sys/users`, `/sys/stats`).
* **data** — general application data (`/data/tasks/...`).
* **user** — user‑specific repos (`/user/alice/preferences`).
* Custom types encouraged (`/team/engineering/roadmap`).

---

## Commit Graph

The underlying data structure is an **append‑only commit graph** (a CRDT) similar to Git but immutable — commits are only added.

* Each commit is signed with the creator’s ECDSA P‑384 private key, enabling network‑wide verification.
* The graph acts as a logical clock ensuring **causal consistency**.
* Nodes append commits locally; background sync merges them.
* **Delta compression** stores either a delta against the last full snapshot or a full snapshot, whichever is smaller; periodic full snapshots (~every 20 commits) bound read chains.

---

## Conflict Resolution

When parallel edits create divergent leaves, GoatDB performs a **three‑way merge**:

1. Convert the base version into a short‑lived CRDT inspired by Logoot.
2. Apply diffs from both branches.
3. Collapse back to plain data and save as a new commit.

Strategies for concurrent inserts/deletes rely on continuous identifiers and deterministic ordering (commit IDs) so every node converges.

---

## Synchronization Protocol

GoatDB synchronizes nodes via iterative **Bloom‑filter exchange**:

1. Node A sends a Bloom filter of its commit IDs.
2. Node B sends back any commits that are definitely missing.
3. Both sides repeat with different hash functions; misses shrink geometrically.
4. Formula bounds iterations: `cycles = 2 × log_fpr(max(M,N))`.
5. Each commit references *K* older ancestors; with `fpr ≤ 0.001`, missing a run of 3 commits is astronomically unlikely.

This stateless algorithm avoids Git’s multiple round‑trip reconciliation and scales to real‑time collaboration.

---

## Sessions and Users

Sessions are secure connections represented by ECDSA P‑384 key pairs. The private key never leaves the client; all commits are signed locally.

* **Anonymous** and **identified** sessions supported.
* Commit signatures guarantee integrity and accountability.
* Because clients keep a full verified commit graph, any client can restore a crashed peer.

---

## Authorization

Authorization rules pair a path pattern with a function that decides access.

```typescript
DataRegistry.default.registerAuthRule(
  '/public/*',
  ({ session, op }) => op === 'read' || session.owner !== undefined,
);
```

Built‑in rules:

* `/sys/sessions` — read‑only
* `/sys/stats` — no access
* `/sys/*` — optionally root‑only

---

## Schema

Schemas are plain JS objects compiled into the GoatDB executable — not stored in the DB. They’re versioned and may include an `upgrade` function.

```typescript
export const kSchemeMessageV2 = {
  ns: 'message',
  version: 2,
  fields: {
    sender: { type: 'string', required: true },
    contents: { type: 'string', required: true },
    timestamp: { type: 'date', default: () => new Date() },
    upgrade: (data) => {
      data.set('contents', data.get('value'));
      return data;
    },
  },
} as const;
```

Supported field types: `number`, `boolean`, `date`, `set`, `map`, `richtext`.

---

## Real‑Time Query Mechanism

Every node keeps a full local copy of the DB, so queries are low‑latency and offline‑capable.

* Incrementally re‑evaluates changed items on new commits.
* Can chain queries to act as lightweight indexes.
* Sorting by field name enables O(log n) lookups.
* Optimizations: Bloom filters, result caching, incremental updates, persistent disk cache.

Example of chained queries:

```typescript
const important = new Query({ source: repo, predicate: ({ item }) => item.get('important') });
const recentImportant = new Query({ source: important, predicate: ({ item }) => isRecent(item.get('date')) });
```

---

## GoatDB React Hooks

| Hook | Purpose |
| ---- | ------- |
| `useDB()` | Initialize & return DB instance |
| `useDBReady()` | Track loading/ready/error state |
| `useQuery()` | Reactive queries that update UI automatically |
| `useItem()` | Subscribe to a single item, returns mutable `ManagedItem` |

```tsx
const tasks = useQuery({
  schema: taskSchema,
  source: '/data/tasks',
  predicate: (item) => !item.get('done'),
  sortBy: 'dateCreated',
  showIntermittentResults: true,
});
```

---

## Building a Todo List App with GoatDB

Step‑by‑step tutorial:

1. **Define schema** `task` with `text`, `done`, `dateCreated`.
2. **Register auth rule** limiting access to `/data/<userId>`.
3. Create React components: `Header`, `TaskItem`, `Contents`, `Login`.
4. Test in two browser tabs—real‑time sync, conflict resolution in action.
5. Build produces a single executable for Linux/macOS/Windows.

---

## GoatDB FAQ

**What is GoatDB?** — A distributed, edge‑native DB inspired by Git, optimized for read‑heavy workloads and offline operation.

* **Overload the client?** Modern devices can handle it; data has to be local to render anyway.
* **Sensitive data?** Same access controls as cloud apps; only data you allow is synced.
* **Deletes?** Append‑only graph + garbage collection.
* **Offline?** Built‑in; peer‑to‑peer WebRTC upcoming.
* **Schema migrations?** Versioned schemas with upgrade functions.
* **Licensing?** Choose AGPL (open) or ELv2 (commercial).

---

*End of document*

