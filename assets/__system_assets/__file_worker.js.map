{
  "version": 3,
  "sources": ["../base/tuple.ts", "../base/version-number.ts", "../logging/entry.ts", "../logging/console-stream.ts", "../logging/log.ts", "../base/error.ts", "https://jsr.io/@std/path/1.0.8/_os.ts", "https://jsr.io/@std/path/1.0.8/_common/assert_path.ts", "https://jsr.io/@std/path/1.0.8/_common/basename.ts", "https://jsr.io/@std/path/1.0.8/_common/strip_trailing_separators.ts", "https://jsr.io/@std/path/1.0.8/posix/_util.ts", "https://jsr.io/@std/path/1.0.8/posix/basename.ts", "https://jsr.io/@std/path/1.0.8/windows/_util.ts", "https://jsr.io/@std/path/1.0.8/windows/basename.ts", "https://jsr.io/@std/path/1.0.8/basename.ts", "https://jsr.io/@std/path/1.0.8/_common/dirname.ts", "https://jsr.io/@std/path/1.0.8/posix/dirname.ts", "https://jsr.io/@std/path/1.0.8/windows/dirname.ts", "https://jsr.io/@std/path/1.0.8/dirname.ts", "https://jsr.io/@std/path/1.0.8/_common/normalize.ts", "https://jsr.io/@std/path/1.0.8/_common/normalize_string.ts", "https://jsr.io/@std/path/1.0.8/posix/normalize.ts", "https://jsr.io/@std/path/1.0.8/windows/normalize.ts", "https://jsr.io/@std/path/1.0.8/normalize.ts", "../base/json-log/file-impl-deno.ts", "../base/json-log/file-impl-opfs.ts", "../base/json-log/file-impl.ts", "../__file_worker/json-log.worker.ts"],
  "sourcesContent": ["export type Tuple4 = number;\n\nexport type Tuple4Position = 0 | 1 | 2 | 3;\n\nexport type Tuple4Values = [number, number, number, number];\n\nexport function tuple4Get(tuple: Tuple4, pos: Tuple4Position): number {\n  return ((tuple & (255 << (pos * 8))) >> (pos * 8)) & 255;\n}\n\nexport function tuple4Set(\n  tuple: Tuple4,\n  pos: Tuple4Position,\n  value: number,\n): Tuple4 {\n  const mask = ~(255 << (pos * 8));\n  value &= 255;\n  return (tuple & mask) | (value << (pos * 8));\n}\n\nexport function tuple4Make(values: Tuple4Values): Tuple4 {\n  return (\n    (values[3] & 255) |\n    ((values[2] & 255) << 8) |\n    ((values[1] & 255) << 16) |\n    ((values[0] & 255) << 24)\n  );\n}\n\nexport function tuple4Break(tuple: Tuple4): Tuple4Values {\n  return [\n    tuple4Get(tuple, 3),\n    tuple4Get(tuple, 2),\n    tuple4Get(tuple, 1),\n    tuple4Get(tuple, 0),\n  ];\n}\n\nexport function tuple4ToString(tuple: Tuple4): string {\n  const lastValue = tuple4Get(tuple, 0);\n  return `${tuple4Get(tuple, 3)}.${tuple4Get(tuple, 2)}.${tuple4Get(tuple, 1)}${\n    lastValue ? `-${lastValue}` : ''\n  }`;\n}\n", "import { Tuple4, tuple4Make } from './tuple.ts';\n\nexport type VersionNumber = Tuple4;\n\n// 21/1/2024\nexport const V3_0_0: VersionNumber = tuple4Make([3, 0, 0, 0]);\n// 25/1/2024\nexport const V3_0_1: VersionNumber = tuple4Make([3, 0, 1, 0]);\n// 1/2/2024\nexport const V3_0_2: VersionNumber = tuple4Make([3, 0, 2, 0]);\n// 8/2/2024\nexport const V3_1_0: VersionNumber = tuple4Make([3, 1, 0, 0]);\n// 11/2/2024\nexport const V3_1_1: VersionNumber = tuple4Make([3, 1, 1, 0]);\n// 14/2/2024\nexport const V3_1_2: VersionNumber = tuple4Make([3, 1, 2, 0]);\n// 15/2/2024\nexport const V3_1_3: VersionNumber = tuple4Make([3, 1, 3, 0]);\n// 19/2/2024\nexport const V3_1_4: VersionNumber = tuple4Make([3, 1, 4, 0]);\n// 26/2/2024\nexport const V3_2_0: VersionNumber = tuple4Make([3, 2, 0, 0]);\n// 17/3/2024\nexport const V3_3_0: VersionNumber = tuple4Make([3, 3, 0, 0]);\n// 19/3/2024\nexport const V3_4_0: VersionNumber = tuple4Make([3, 4, 0, 0]);\n// 26/3/2024\nexport const V3_4_1: VersionNumber = tuple4Make([3, 4, 1, 0]);\n// 17/4/2024\nexport const V3_4_2: VersionNumber = tuple4Make([3, 4, 2, 0]);\n// 18/4/2024\nexport const V3_4_3: VersionNumber = tuple4Make([3, 4, 3, 0]);\n// 5/5/2024\nexport const V3_4_4: VersionNumber = tuple4Make([3, 4, 4, 0]);\n// 9/5/2024\nexport const V3_4_5: VersionNumber = tuple4Make([3, 4, 5, 0]);\n// 21/5/2024\nexport const V3_4_6: VersionNumber = tuple4Make([3, 4, 6, 0]);\nexport const V3_4_7: VersionNumber = tuple4Make([3, 4, 7, 0]);\nexport const V3_5_0: VersionNumber = tuple4Make([3, 5, 0, 0]);\n\nexport const VCurrent = V3_4_7;\n", "import { JSONObject, ReadonlyJSONObject } from '../base/interfaces.ts';\nimport { tuple4ToString } from '../base/tuple.ts';\nimport { VCurrent } from '../base/version-number.ts';\n\nexport type Severity =\n  | 'EMERGENCY'\n  | 'ALERT'\n  | 'CRITICAL'\n  | 'ERROR'\n  | 'WARNING'\n  | 'NOTICE'\n  | 'METRIC'\n  | 'EVENT'\n  | 'INFO'\n  | 'DEBUG'\n  | 'DEFAULT';\n\nexport const SeverityCodes: { [key in Severity]: number } = {\n  EMERGENCY: 800,\n  ALERT: 700,\n  CRITICAL: 600,\n  ERROR: 500,\n  WARNING: 400,\n  NOTICE: 300,\n  METRIC: 250,\n  EVENT: 225,\n  INFO: 200,\n  DEBUG: 100,\n  DEFAULT: 0,\n};\n\nexport function SeverityCodeFromSeverity(s: Severity): number {\n  return SeverityCodes[s];\n}\n\nexport function SeverityFromCode(code: number): Severity {\n  switch (code) {\n    case SeverityCodes.EMERGENCY:\n      return 'EMERGENCY';\n\n    case SeverityCodes.ALERT:\n      return 'ALERT';\n\n    case SeverityCodes.CRITICAL:\n      return 'CRITICAL';\n\n    case SeverityCodes.ERROR:\n      return 'ERROR';\n\n    case SeverityCodes.WARNING:\n      return 'WARNING';\n\n    case SeverityCodes.NOTICE:\n      return 'NOTICE';\n\n    case SeverityCodes.INFO:\n      return 'INFO';\n\n    case SeverityCodes.METRIC:\n      return 'METRIC';\n\n    case SeverityCodes.EVENT:\n      return 'EVENT';\n\n    case SeverityCodes.DEBUG:\n      return 'DEBUG';\n\n    case SeverityCodes.DEFAULT:\n    default:\n      return 'DEFAULT';\n  }\n}\n\nexport interface BaseLogEntry extends JSONObject {\n  severity: Severity;\n  message?: string;\n}\n\nexport interface TechnicalLogData extends JSONObject {\n  severityCode: number;\n  timestamp: number; // ISO 8601 string\n  logId: string;\n  ovvVersion: string;\n\n  t_denoVersion: string;\n  t_v8Version: string;\n  t_tsVersion: string;\n  // Hostname\n  t_hostname: string;\n  // OS Process ID\n  t_pid: number;\n  // OS Build information\n  t_osBuild: ReadonlyJSONObject;\n  // The main module that was executed, if available\n  t_mainUrl: string;\n  // Path to executable (deno/packaged)\n  t_execPath: string;\n}\n\nexport interface GenericLogEntry extends BaseLogEntry {\n  severity: 'INFO' | 'DEBUG' | 'DEFAULT';\n  message: string;\n}\n\nexport type NormalizedLogEntry<T extends BaseLogEntry = BaseLogEntry> = T &\n  TechnicalLogData;\n\nexport function normalizeLogEntry<T extends BaseLogEntry = BaseLogEntry>(\n  e: T,\n): NormalizedLogEntry<T> {\n  const res: NormalizedLogEntry<T> = e as unknown as NormalizedLogEntry<T>;\n  res.severityCode = SeverityCodes[e.severity];\n  res.timestamp = Date.now();\n  res.logId = uniqueId();\n  res.ovvVersion = tuple4ToString(VCurrent);\n  if (typeof Deno !== 'undefined') {\n    try {\n      res.t_denoVersion = Deno.version.deno;\n      res.t_v8Version = Deno.version.v8;\n      res.t_tsVersion = Deno.version.typescript;\n      res.t_hostname = Deno.hostname();\n      res.t_pid = Deno.pid;\n      res.t_osBuild = Deno.build;\n      res.t_mainUrl = Deno.mainModule;\n      res.t_execPath = Deno.execPath();\n    } catch (_e: unknown) {\n      // Ignore any errors here\n    }\n  }\n  for (const field of Object.keys(res)) {\n    if (typeof res[field] === 'undefined') {\n      delete res[field];\n    }\n  }\n  return res;\n}\n\nfunction uniqueId(length = 20): string {\n  // Alphanumeric characters\n  const chars =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let autoId = '';\n  for (let i = 0; i < length; i++) {\n    autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return autoId;\n}\n", "import { NormalizedLogEntry, Severity, SeverityFromCode } from './entry.ts';\nimport { LogEntry, LogStream } from './log.ts';\n\nexport class ConsoleLogStream implements LogStream {\n  severity: Severity;\n  constructor(severity: Severity | number = 'DEFAULT') {\n    this.severity = typeof severity === 'number'\n      ? SeverityFromCode(severity)\n      : severity;\n  }\n\n  appendEntry(e: NormalizedLogEntry<LogEntry>): void {\n    let textLog = `[${new Date(e.timestamp).toISOString()}] `;\n    if (typeof e.message === 'string') {\n      textLog += e.message + ': ';\n    }\n    textLog += JSON.stringify(e, null, 2);\n    switch (e.severity as Severity) {\n      case 'EMERGENCY':\n      case 'ALERT':\n      case 'CRITICAL':\n      case 'ERROR':\n        console.error(textLog);\n        throw new Error(textLog);\n\n      case 'WARNING':\n      case 'NOTICE':\n        console.warn(textLog);\n        break;\n\n      case 'INFO':\n      case 'DEFAULT':\n        console.log(textLog);\n        break;\n\n      case 'DEBUG':\n      case 'METRIC':\n      case 'EVENT':\n        console.debug(textLog);\n        break;\n    }\n  }\n}\n", "import {\n  LogEntryDeveloperError,\n  OperationalErrorLogEntry,\n  SystemErrorLogEntry,\n} from './errors.ts';\nimport {\n  GenericLogEntry,\n  NormalizedLogEntry,\n  normalizeLogEntry,\n  Severity,\n  SeverityCodes,\n} from './entry.ts';\nimport { MetricLogEntry } from './metrics.ts';\nimport { ClientEventEntry } from './client-events.ts';\nimport { ConsoleLogStream } from './console-stream.ts';\n\n/**\n * A union type of all possible log entries.\n */\nexport type LogEntry =\n  | GenericLogEntry\n  | LogEntryDeveloperError\n  | OperationalErrorLogEntry\n  | SystemErrorLogEntry\n  | MetricLogEntry\n  | ClientEventEntry;\n\nexport interface LogStream {\n  appendEntry(e: NormalizedLogEntry<LogEntry>): void;\n}\n\n// TODO: Capture anonymous logs on client and sync them with the server\nconst kDefaultLoggerStreams: LogStream[] = [new ConsoleLogStream()];\n\nlet gLogStreams: readonly LogStream[] = kDefaultLoggerStreams;\n\nlet gLogLevel = SeverityCodes.DEFAULT;\n\nexport function setGlobalLoggerStreams(streams: readonly LogStream[]): void {\n  gLogStreams = streams;\n}\n\nexport function resetGlobalLoggerStreams(): void {\n  gLogStreams = kDefaultLoggerStreams;\n}\n\nexport function setGlobalLoggerSeverity(level: Severity): void {\n  gLogLevel = SeverityCodes[level];\n}\n\nexport function log(\n  entry: LogEntry,\n  outputStreams: readonly LogStream[] | undefined = gLogStreams\n): void {\n  if (!outputStreams) {\n    outputStreams = gLogStreams;\n  }\n  if (SeverityCodes[entry.severity] >= gLogLevel) {\n    const e = normalizeLogEntry(entry);\n    for (const stream of outputStreams) {\n      stream.appendEntry(e);\n    }\n  }\n}\n\nexport interface Logger {\n  log(entry: LogEntry): void;\n}\n\nexport function newLogger(outputStreams: LogStream[]): Logger {\n  return {\n    log(entry: LogEntry): void {\n      log(entry, outputStreams);\n    },\n  };\n}\n\nexport const GlobalLogger = {\n  log(entry: LogEntry): void {\n    log(entry, gLogStreams);\n  },\n};\n", "import { log } from '../logging/log.ts';\n\nexport function notImplemented(): never {\n  const error = new Error('Not Implemented');\n  log({ severity: 'ERROR', error: 'NotImplemented', trace: error.stack });\n  throw error;\n}\n\nexport function notReached(msg?: string): never {\n  const error = new Error(msg);\n  log({\n    severity: 'ERROR',\n    error: 'NotReached',\n    message: msg,\n    trace: error.stack,\n  });\n  throw error;\n}\n\nexport function assert(condition: boolean, msg?: string): asserts condition {\n  if (!condition) {\n    msg = msg ? `Failed Assertion: \"${msg}\"` : 'Failed Assertion';\n    debugger;\n    const error = new Error(msg);\n    log({\n      severity: 'ERROR',\n      error: 'FailedAssertion',\n      message: msg,\n      trace: error.stack,\n    });\n    throw error;\n  }\n}\n", "// deno-lint-ignore-file no-explicit-any\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\n// Check Deno, then the remaining runtimes (e.g. Node, Bun and the browser)\nexport const isWindows: boolean =\n  (globalThis as any).Deno?.build.os === \"windows\" ||\n  (globalThis as any).navigator?.platform?.startsWith(\"Win\") ||\n  (globalThis as any).process?.platform?.startsWith(\"win\") ||\n  false;\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n\nexport function assertPath(path?: string) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(\n      `Path must be a string, received \"${JSON.stringify(path)}\"`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function stripSuffix(name: string, suffix: string): string {\n  if (suffix.length >= name.length) {\n    return name;\n  }\n\n  const lenDiff = name.length - suffix.length;\n\n  for (let i = suffix.length - 1; i >= 0; --i) {\n    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n      return name;\n    }\n  }\n\n  return name.slice(0, -suffix.length);\n}\n\nexport function lastPathSegment(\n  path: string,\n  isSep: (char: number) => boolean,\n  start = 0,\n): string {\n  let matchedNonSeparator = false;\n  let end = path.length;\n\n  for (let i = path.length - 1; i >= start; --i) {\n    if (isSep(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        start = i + 1;\n        break;\n      }\n    } else if (!matchedNonSeparator) {\n      matchedNonSeparator = true;\n      end = i + 1;\n    }\n  }\n\n  return path.slice(start, end);\n}\n\nexport function assertArgs(path: string, suffix: string) {\n  assertPath(path);\n  if (path.length === 0) return path;\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(\n      `Suffix must be a string, received \"${JSON.stringify(suffix)}\"`,\n    );\n  }\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nexport function stripTrailingSeparators(\n  segment: string,\n  isSep: (char: number) => boolean,\n): string {\n  if (segment.length <= 1) {\n    return segment;\n  }\n\n  let end = segment.length;\n\n  for (let i = segment.length - 1; i > 0; i--) {\n    if (isSep(segment.charCodeAt(i))) {\n      end = i;\n    } else {\n      break;\n    }\n  }\n\n  return segment.slice(0, end);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport { CHAR_FORWARD_SLASH } from \"../_common/constants.ts\";\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  assertArgs,\n  lastPathSegment,\n  stripSuffix,\n} from \"../_common/basename.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"/home/user/Documents/\"), \"Documents\");\n * assertEquals(basename(\"/home/user/Documents/image.png\"), \"image.png\");\n * assertEquals(basename(\"/home/user/Documents/image.png\", \".png\"), \"image\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function doesn't automatically strip hash and query parts from\n * URLs. If your URL contains a hash or query, remove them before passing the\n * URL to the function. This can be done by passing the URL to `new URL(url)`,\n * and setting the `hash` and `search` properties to empty strings.\n *\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\"), \"mod.ts\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\", \".ts\"), \"mod\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts?a=b\"), \"mod.ts?a=b\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts#header\"), \"mod.ts#header\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/posix/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertArgs(path, suffix);\n\n  const lastSegment = lastPathSegment(path, isPosixPathSeparator);\n  const strippedSegment = stripTrailingSeparators(\n    lastSegment,\n    isPosixPathSeparator,\n  );\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport {\n  CHAR_BACKWARD_SLASH,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n} from \"../_common/constants.ts\";\n\nexport function isPosixPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nexport function isPathSeparator(code: number): boolean {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nexport function isWindowsDeviceRoot(code: number): boolean {\n  return (\n    (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z)\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport {\n  assertArgs,\n  lastPathSegment,\n  stripSuffix,\n} from \"../_common/basename.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/windows/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\\"), \"Documents\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\"), \"image.png\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\", \".png\"), \"image\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/windows/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  assertArgs(path, suffix);\n\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  let start = 0;\n  if (path.length >= 2) {\n    const drive = path.charCodeAt(0);\n    if (isWindowsDeviceRoot(drive)) {\n      if (path.charCodeAt(1) === CHAR_COLON) start = 2;\n    }\n  }\n\n  const lastSegment = lastPathSegment(path, isPathSeparator, start);\n  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { basename as posixBasename } from \"./posix/basename.ts\";\nimport { basename as windowsBasename } from \"./windows/basename.ts\";\n\n/**\n * Return the last portion of a path.\n *\n * The trailing directory separators are ignored, and optional suffix is\n * removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\"), \"image.png\");\n * } else {\n *   assertEquals(basename(\"/home/user/Documents/image.png\"), \"image.png\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/unstable-basename`.\n *\n * @param path Path to extract the name from.\n * @param suffix Suffix to remove from extracted name.\n *\n * @returns The basename of the path.\n */\nexport function basename(path: string, suffix = \"\"): string {\n  return isWindows\n    ? windowsBasename(path, suffix)\n    : posixBasename(path, suffix);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function assertArg(path: string) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/dirname.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"/home/user/Documents/\"), \"/home/user\");\n * assertEquals(dirname(\"/home/user/Documents/image.png\"), \"/home/user/Documents\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * ```\n *\n * @example Working with URLs\n *\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts?a=b\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts#header\"), \"https://deno.land/std/path\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/posix/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  assertArg(path);\n\n  let end = -1;\n  let matchedNonSeparator = false;\n\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (isPosixPathSeparator(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedNonSeparator = true;\n    }\n  }\n\n  // No matches. Fallback based on provided path:\n  //\n  // - leading slashes paths\n  //     \"/foo\" => \"/\"\n  //     \"///foo\" => \"/\"\n  // - no slash path\n  //     \"foo\" => \".\"\n  if (end === -1) {\n    return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\n  }\n\n  return stripTrailingSeparators(\n    path.slice(0, end),\n    isPosixPathSeparator,\n  );\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/dirname.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { stripTrailingSeparators } from \"../_common/strip_trailing_separators.ts\";\nimport {\n  isPathSeparator,\n  isPosixPathSeparator,\n  isWindowsDeviceRoot,\n} from \"./_util.ts\";\n\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/windows/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const dir = dirname(\"C:\\\\foo\\\\bar\\\\baz.ext\");\n * assertEquals(dir, \"C:\\\\foo\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/windows/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  assertArg(path);\n\n  const len = path.length;\n  let rootEnd = -1;\n  let end = -1;\n  let matchedSlash = true;\n  let offset = 0;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    return path;\n  }\n\n  for (let i = len - 1; i >= offset; --i) {\n    if (isPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return \".\";\n    else end = rootEnd;\n  }\n  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { dirname as posixDirname } from \"./posix/dirname.ts\";\nimport { dirname as windowsDirname } from \"./windows/dirname.ts\";\n\n/**\n * Return the directory path of a path.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(dirname(\"C:\\\\home\\\\user\\\\Documents\\\\image.png\"), \"C:\\\\home\\\\user\\\\Documents\");\n * } else {\n *   assertEquals(dirname(\"/home/user/Documents/image.png\"), \"/home/user/Documents\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/unstable-dirname`.\n *\n * @param path Path to extract the directory from.\n * @returns The directory path.\n */\nexport function dirname(path: string): string {\n  return isWindows ? windowsDirname(path) : posixDirname(path);\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertPath } from \"./assert_path.ts\";\n\nexport function assertArg(path: string) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n\nimport { CHAR_DOT, CHAR_FORWARD_SLASH } from \"./constants.ts\";\n\n// Resolves . and .. elements in a path with directory names\nexport function normalizeString(\n  path: string,\n  allowAboveRoot: boolean,\n  separator: string,\n  isPathSeparator: (code: number) => boolean,\n): string {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) code = path.charCodeAt(i);\n    else if (isPathSeparator(code!)) break;\n    else code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code!)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n          res.charCodeAt(res.length - 2) !== CHAR_DOT\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/normalize.ts\";\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { isPosixPathSeparator } from \"./_util.ts\";\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = normalize(\"/foo/bar//baz/asdf/quux/..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function will remove the double slashes from a URL's scheme.\n * Hence, do not pass a full URL to this function. Instead, pass the pathname of\n * the URL.\n *\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const url = new URL(\"https://deno.land\");\n * url.pathname = normalize(\"//std//assert//.//mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/assert/mod.ts\");\n *\n * url.pathname = normalize(\"std/assert/../async/retry.ts\");\n * assertEquals(url.href, \"https://deno.land/std/async/retry.ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/posix/unstable-normalize`.\n *\n * @param path The path to normalize.\n * @returns The normalized path.\n */\nexport function normalize(path: string): string {\n  assertArg(path);\n\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  const trailingSeparator = isPosixPathSeparator(\n    path.charCodeAt(path.length - 1),\n  );\n\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { assertArg } from \"../_common/normalize.ts\";\nimport { CHAR_COLON } from \"../_common/constants.ts\";\nimport { normalizeString } from \"../_common/normalize_string.ts\";\nimport { isPathSeparator, isWindowsDeviceRoot } from \"./_util.ts\";\n\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/windows/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const normalized = normalize(\"C:\\\\foo\\\\..\\\\bar\");\n * assertEquals(normalized, \"C:\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/windows/unstable-normalize`.\n *\n * @param path The path to normalize\n * @returns The normalized path\n */\nexport function normalize(path: string): string {\n  assertArg(path);\n\n  const len = path.length;\n  let rootEnd = 0;\n  let device: string | undefined;\n  let isAbsolute = false;\n  const code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            // Treat separator following drive name as an absolute path\n            // indicator\n            isAbsolute = true;\n            rootEnd = 3;\n          }\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid unnecessary\n    // work\n    return \"\\\\\";\n  }\n\n  let tail: string;\n  if (rootEnd < len) {\n    tail = normalizeString(\n      path.slice(rootEnd),\n      !isAbsolute,\n      \"\\\\\",\n      isPathSeparator,\n    );\n  } else {\n    tail = \"\";\n  }\n  if (tail.length === 0 && !isAbsolute) tail = \".\";\n  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n    tail += \"\\\\\";\n  }\n  if (device === undefined) {\n    if (isAbsolute) {\n      if (tail.length > 0) return `\\\\${tail}`;\n      else return \"\\\\\";\n    }\n    return tail;\n  } else if (isAbsolute) {\n    if (tail.length > 0) return `${device}\\\\${tail}`;\n    else return `${device}\\\\`;\n  }\n  return device + tail;\n}\n", "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n\nimport { isWindows } from \"./_os.ts\";\nimport { normalize as posixNormalize } from \"./posix/normalize.ts\";\nimport { normalize as windowsNormalize } from \"./windows/normalize.ts\";\n/**\n * Normalize the path, resolving `'..'` and `'.'` segments.\n *\n * Note: Resolving these segments does not necessarily mean that all will be\n * eliminated. A `'..'` at the top-level will be preserved, and an empty path is\n * canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * if (Deno.build.os === \"windows\") {\n *   assertEquals(normalize(\"C:\\\\foo\\\\bar\\\\..\\\\baz\\\\quux\"), \"C:\\\\foo\\\\baz\\\\quux\");\n * } else {\n *   assertEquals(normalize(\"/foo/bar/../baz/quux\"), \"/foo/baz/quux\");\n * }\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/unstable-normalize`.\n *\n * @param path Path to be normalized\n * @returns The normalized path.\n */\nexport function normalize(path: string): string {\n  return isWindows ? windowsNormalize(path) : posixNormalize(path);\n}\n", "import * as path from '@std/path';\nimport { FileImpl } from './file-impl-interface.ts';\n\nexport const FileImplDeno: FileImpl<Deno.FsFile> = {\n  async open(filePath, write) {\n    // try {\n    await Deno.mkdir(path.dirname(filePath), { recursive: true });\n    // } catch (_: unknown) {}\n    return Deno.open(filePath, {\n      read: true,\n      write,\n      create: write,\n    });\n  },\n\n  seek(handle, offset, from) {\n    let whence: Deno.SeekMode;\n    switch (from) {\n      case 'start':\n        whence = Deno.SeekMode.Start;\n        break;\n\n      case 'current':\n        whence = Deno.SeekMode.Current;\n        break;\n\n      case 'end':\n        whence = Deno.SeekMode.End;\n        break;\n    }\n    return handle.seek(offset, whence);\n  },\n\n  read(handle, buf) {\n    return handle.read(buf);\n  },\n\n  truncate(handle, len) {\n    return handle.truncate(len);\n  },\n\n  async write(handle, buf) {\n    let bytesWritten = 0;\n    while (bytesWritten < buf.byteLength) {\n      const arr = buf.subarray(bytesWritten);\n      bytesWritten += await handle.write(arr);\n    }\n  },\n\n  close(handle) {\n    handle.close();\n    return Promise.resolve();\n  },\n\n  flush(handle) {\n    return handle.sync();\n  },\n};\n", "import * as path from '@std/path';\nimport { FileImpl } from './file-impl-interface.ts';\n\ninterface FileSystemSyncAccessHandle {\n  close(): void;\n  getSize(): number;\n  flush(): void;\n  read(buffer: Uint8Array, opts?: { at?: number }): number;\n  truncate(size: number): void;\n  write(buffer: Uint8Array, opts?: { at?: number }): number;\n}\n\ninterface OPFSFile {\n  handle: FileSystemFileHandle;\n  file: FileSystemSyncAccessHandle;\n  pos: number;\n}\n\nasync function getDir(dirPath: string): Promise<FileSystemDirectoryHandle> {\n  const root = await navigator.storage.getDirectory();\n  dirPath = path.normalize(dirPath);\n  const comps = dirPath.split('/');\n  let parent = root;\n  for (const c of comps) {\n    if (c.length === 0) {\n      continue;\n    }\n    parent = await parent.getDirectoryHandle(c, { create: true });\n  }\n  return parent;\n}\n\nexport const FileImplOPFS: FileImpl<OPFSFile> = {\n  async open(filePath, write) {\n    const dir = await getDir(path.dirname(filePath));\n    const handle = await dir.getFileHandle(path.basename(filePath), {\n      create: write,\n    });\n    return {\n      handle,\n      file: await handle.createSyncAccessHandle(),\n      pos: 0,\n    };\n  },\n\n  seek(handle, offset, from) {\n    switch (from) {\n      case 'current':\n        offset += handle.pos;\n        break;\n\n      case 'start':\n        break;\n\n      case 'end':\n        offset = handle.file.getSize() - offset;\n        break;\n    }\n    handle.pos = offset;\n    return Promise.resolve(offset);\n  },\n\n  read(handle, buf) {\n    if (handle.pos >= handle.file.getSize()) {\n      return Promise.resolve(null);\n    }\n    const readLen = handle.file.read(buf, { at: handle.pos });\n    handle.pos += readLen;\n    return Promise.resolve(readLen);\n  },\n\n  truncate(handle, len) {\n    len = Math.max(0, len);\n    handle.file.truncate(len);\n    handle.pos = Math.min(len, handle.pos);\n    return Promise.resolve();\n  },\n\n  write(handle, buf) {\n    let bytesWritten = 0;\n    while (bytesWritten < buf.byteLength) {\n      const arr = buf.subarray(bytesWritten);\n      const len = handle.file.write(arr, { at: handle.pos });\n      bytesWritten += len;\n      handle.pos += len;\n    }\n    return Promise.resolve();\n  },\n\n  close(handle) {\n    handle.file.close();\n    return Promise.resolve();\n  },\n\n  flush(handle) {\n    handle.file.flush();\n    return Promise.resolve();\n  },\n};\n", "import { FileImplDeno } from './file-impl-deno.ts';\nimport type { FileImpl } from './file-impl-interface.ts';\nimport { FileImplOPFS } from './file-impl-opfs.ts';\n\nexport function FileImplGet(): FileImpl<unknown> {\n  return self.Deno === undefined ? FileImplOPFS : FileImplDeno;\n}\n", "/**\n * This file implements a background worker for the JSONLogFile interface in\n * json-log-background.ts\n */\nimport { assert } from '../base/error.ts';\nimport { ReadonlyJSONObject } from '../base/interfaces.ts';\nimport {\n  WorkerFileReq,\n  WorkerFileRespAppend,\n  WorkerFileRespClose,\n  WorkerFileRespCursor,\n  WorkerFileRespFlush,\n  WorkerFileRespOpen,\n  WorkerFileRespScan,\n  WorkerReadTextFileResp,\n  WorkerWriteTextFileReq,\n  WorkerWriteTextFileResp,\n} from '../base/json-log/json-log-worker-req.ts';\nimport { FileImpl } from '../base/json-log/file-impl-interface.ts';\nimport { FileImplGet } from '../base/json-log/file-impl.ts';\nimport * as SetUtils from '../base/set.ts';\n\nconst FILE_READ_BUF_SIZE_BYTES = 1024 * 1024; // 8KB\nconst PAGE_SIZE = 1024;\nconst LINE_DELIMITER_BYTE = 10; // \"\\n\"\n\nconst textDecoder = new TextDecoder();\n\ninterface JSONLogFile {\n  readonly path: string;\n  readonly write: boolean;\n  readonly impl: FileImpl<unknown>;\n  readonly knownIds: Set<string>;\n  handle: unknown;\n  didScan?: true;\n  pendingWrites: ReadonlyJSONObject[];\n  writePromise?: Promise<void>;\n}\n\nasync function JSONLogFileOpen(\n  path: string,\n  write = false,\n): Promise<JSONLogFile> {\n  const impl = FileImplGet();\n  return {\n    path,\n    write: write === true,\n    impl,\n    handle: await impl.open(path, write),\n    pendingWrites: [],\n    knownIds: new Set(),\n  };\n}\n\nfunction JSONLogFileClose(file: JSONLogFile): Promise<void> {\n  return file.impl.close(file.handle);\n}\n\ninterface JSONLogFileCursor {\n  readonly file: JSONLogFile;\n  readonly totalFileBytes: number;\n  fileOffset: number;\n  readBuf: Uint8Array;\n  readBufLen: number;\n  readBufStart: number;\n  readBufEnd: number;\n  lastGoodFileOffset: number;\n  objectBuf: Uint8Array;\n  objectBufOffset: number;\n}\n\nasync function JSONLogFileStartCursor(\n  file: JSONLogFile,\n): Promise<JSONLogFileCursor> {\n  const totalFileBytes = await file.impl.seek(file.handle, 0, 'end');\n  await file.impl.seek(file.handle, 0, 'start');\n  return {\n    file,\n    totalFileBytes,\n    fileOffset: 0,\n    readBuf: new Uint8Array(FILE_READ_BUF_SIZE_BYTES),\n    readBufLen: 0,\n    readBufStart: 0,\n    readBufEnd: 0,\n    lastGoodFileOffset: 0,\n    objectBuf: new Uint8Array(PAGE_SIZE),\n    objectBufOffset: 0,\n  };\n}\n\ntype ScanResult = [results: readonly ReadonlyJSONObject[], done: boolean];\nasync function JSONLogFileScan(cursor: JSONLogFileCursor): Promise<ScanResult> {\n  const pendingObjects: ReadonlyJSONObject[] = [];\n  while (pendingObjects.length <= 50) {\n    while (cursor.readBufLen <= 0) {\n      const bytesRead = await cursor.file.impl.read(\n        cursor.file.handle,\n        cursor.readBuf,\n      );\n      // next read()\n      if (bytesRead === null) {\n        if (cursor.objectBufOffset > 0 && cursor.file.write) {\n          await cursor.file.impl.seek(cursor.file.handle, 0, 'end');\n          await cursor.file.impl.truncate(\n            cursor.file.handle,\n            cursor.lastGoodFileOffset,\n          );\n        }\n        cursor.file.didScan = true; // Ensure this flag is set correctly\n        return [pendingObjects, true];\n      }\n      cursor.readBufLen = bytesRead;\n    }\n    while (cursor.readBufStart < cursor.readBufLen) {\n      cursor.readBufEnd = cursor.readBufStart;\n      while (\n        cursor.readBufEnd < cursor.readBufLen &&\n        cursor.readBuf[cursor.readBufEnd] !== LINE_DELIMITER_BYTE\n      ) {\n        ++cursor.readBufEnd;\n      }\n      const readLen = cursor.readBufEnd - cursor.readBufStart;\n      if (readLen > 0) {\n        cursor.fileOffset += readLen;\n        cursor.objectBuf = appendBytes(\n          cursor.readBuf,\n          cursor.readBufStart,\n          readLen,\n          cursor.objectBuf,\n          cursor.objectBufOffset,\n        );\n        cursor.objectBufOffset += readLen;\n        // if (progressCallback) {\n        //   progressCallback(fileOffset / totalFileBytes);\n        // }\n      }\n      cursor.readBufStart = cursor.readBufEnd + 1;\n      if (\n        cursor.readBuf[cursor.readBufEnd] === LINE_DELIMITER_BYTE &&\n        cursor.objectBufOffset > 0\n      ) {\n        try {\n          const text = textDecoder.decode(\n            cursor.objectBuf.subarray(0, cursor.objectBufOffset),\n          );\n          pendingObjects.push(JSON.parse(text));\n          cursor.lastGoodFileOffset += cursor.objectBufOffset + 1; // +1 for newline character\n          cursor.objectBufOffset = 0;\n          // if (pendingObjects.length > 20000) {\n          //   break;\n          // }\n        } catch (_: unknown) {\n          if (cursor.file.write) {\n            await cursor.file.impl.seek(cursor.file.handle, 0, 'end');\n            await cursor.file.impl.truncate(\n              cursor.file.handle,\n              cursor.lastGoodFileOffset,\n            );\n          }\n          cursor.file.didScan = true;\n          for (const o of pendingObjects) {\n            if (typeof o.id === 'string') {\n              cursor.file.knownIds.add(o.id);\n            }\n          }\n          return [pendingObjects, true];\n        }\n      }\n    }\n    if (cursor.readBufStart >= cursor.readBufLen) {\n      cursor.readBufLen = 0;\n      cursor.readBufStart = 0;\n      cursor.readBufEnd = 0;\n    }\n  }\n\n  for (const o of pendingObjects) {\n    if (typeof o.id === 'string') {\n      cursor.file.knownIds.add(o.id);\n    }\n  }\n  return [pendingObjects, false];\n  // cacheBufferForReuse(objectBuf);\n}\n\nfunction JSONLogFileFlush(file: JSONLogFile): Promise<void> {\n  return file.impl.flush(file.handle);\n}\n\nfunction appendBytes(\n  src: Uint8Array,\n  srcOffset: number,\n  srcLen: number,\n  dst: Uint8Array,\n  dstOffset: number,\n): Uint8Array {\n  if (dstOffset + srcLen > dst.byteLength) {\n    const newDst = new Uint8Array(\n      Math.ceil(((dstOffset + srcLen) * 2) / PAGE_SIZE) * PAGE_SIZE,\n    );\n    newDst.set(dst);\n    // cacheBufferForReuse(dst);\n    dst = newDst;\n  }\n  dst.set(src.subarray(srcOffset, srcOffset + srcLen), dstOffset);\n  return dst;\n}\n\nasync function JSONLogFileAppend(\n  file: JSONLogFile,\n  entries: readonly ReadonlyJSONObject[],\n): Promise<void> {\n  assert(file.write, 'Attempting to write to a readonly log');\n  // if (file.writePromise) {\n  //   await file.writePromise;\n  //   const promise = delay<void>(0, async () => {\n  //     await JSONLogFileAppend(file, entries);\n  //     if (file.writePromise === promise) {\n  //       file.writePromise = undefined;\n  //     }\n  //   });\n  //   file.writePromise = promise;\n  //   return;\n  // }\n  assert(\n    file.didScan === true,\n    'Attempting to append to log before initial scan completed',\n  );\n  const filteredEntries: ReadonlyJSONObject[] = [];\n  for (const e of entries) {\n    if (typeof e.id === 'string' && !file.knownIds.has(e.id)) {\n      file.knownIds.add(e.id);\n      filteredEntries.push(e);\n    }\n  }\n  const encodedEntries =\n    '\\n' +\n    filteredEntries.map((obj) => JSON.stringify(obj)).join('\\n\\n') +\n    '\\n';\n  const encodedBuf = new TextEncoder().encode(encodedEntries);\n  await file.impl.seek(file.handle, 0, 'end');\n  await file.impl.write(file.handle, encodedBuf);\n}\n\nconst gOpenFiles = new Map<number, JSONLogFile>();\nlet gFileHandleNum = 0;\nconst gOpenCursors = new Map<\n  number,\n  { cursor: JSONLogFileCursor; nextPromise?: Promise<ScanResult> }\n>();\nlet gOpenCursorNum = 0;\n\nasync function readFile(path: string): Promise<Uint8Array> {\n  const impl = FileImplGet();\n  const handle = await impl.open(path, false);\n  const fileLen = await impl.seek(handle, 0, 'end');\n  await impl.seek(handle, 0, 'start');\n  const buf = new Uint8Array(fileLen);\n  await impl.read(handle, buf);\n  await impl.close(handle);\n  return buf;\n}\n\nasync function readTextFile(path: string): Promise<string | undefined> {\n  try {\n    const decoder = new TextDecoder();\n    return decoder.decode(await readFile(path));\n  } catch (_: unknown) {\n    return undefined;\n  }\n}\n\nasync function writeFile(path: string, buf: Uint8Array): Promise<void> {\n  const impl = FileImplGet();\n  const handle = await impl.open(path, true);\n  await impl.write(handle, buf);\n  await impl.truncate(handle, buf.length);\n  await impl.close(handle);\n}\n\nasync function writeTextFile(path: string, text: string): Promise<boolean> {\n  try {\n    const encoder = new TextEncoder();\n    await writeFile(path, encoder.encode(text));\n    return true;\n  } catch (_: unknown) {\n    return false;\n  }\n}\n\nfunction main(): void {\n  console.log(`WORKER STARTED`);\n  onmessage = async (event: MessageEvent<WorkerFileReq>) => {\n    switch (event.data.type) {\n      case 'open': {\n        const handle = ++gFileHandleNum;\n        const file = await JSONLogFileOpen(event.data.path, event.data.write);\n        gOpenFiles.set(handle, file);\n        const resp: WorkerFileRespOpen = {\n          type: 'open',\n          id: event.data.id,\n          file: handle,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'close': {\n        const file = gOpenFiles.get(event.data.file);\n        if (file) {\n          gOpenFiles.delete(event.data.file);\n          await JSONLogFileClose(file);\n        }\n        const resp: WorkerFileRespClose = {\n          type: 'close',\n          id: event.data.id,\n          file: event.data.file,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'cursor': {\n        const file = gOpenFiles.get(event.data.file);\n        assert(file !== undefined, 'File not found');\n        const cursor = await JSONLogFileStartCursor(file);\n        const cursorId = ++gOpenCursorNum;\n        const nextPromise = JSONLogFileScan(cursor);\n        gOpenCursors.set(cursorId, { cursor, nextPromise });\n        const resp: WorkerFileRespCursor = {\n          type: 'cursor',\n          id: event.data.id,\n          cursor: cursorId,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'scan': {\n        const entry = gOpenCursors.get(event.data.cursor);\n        assert(entry !== undefined, 'Cursor not found');\n        if (!entry.nextPromise) {\n          entry.nextPromise = JSONLogFileScan(entry.cursor);\n        }\n        const [values, done] = await entry.nextPromise;\n        entry.nextPromise = JSONLogFileScan(entry.cursor);\n        const resp: WorkerFileRespScan = {\n          type: 'scan',\n          id: event.data.id,\n          cursor: event.data.cursor,\n          values,\n          done,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'flush': {\n        const file = gOpenFiles.get(event.data.file);\n        assert(file !== undefined, 'File not found');\n        await JSONLogFileFlush(file);\n        const resp: WorkerFileRespFlush = {\n          type: 'flush',\n          id: event.data.id,\n          file: event.data.file,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'append': {\n        const file = gOpenFiles.get(event.data.file);\n        assert(file !== undefined, 'File not found');\n        await JSONLogFileAppend(file, event.data.values);\n        const resp: WorkerFileRespAppend = {\n          type: 'append',\n          id: event.data.id,\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'readTextFile': {\n        const resp: WorkerReadTextFileResp = {\n          type: 'readTextFile',\n          id: event.data.id,\n          text: await readTextFile(event.data.path),\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n\n      case 'writeTextFile': {\n        const resp: WorkerWriteTextFileResp = {\n          type: 'writeTextFile',\n          id: event.data.id,\n          success: await writeTextFile(event.data.path, event.data.text),\n        };\n        postMessage(JSON.stringify(resp));\n        break;\n      }\n    }\n  };\n}\n\nmain();\n"],
  "mappings": "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",
  "names": ["tuple4Get", "tuple", "pos", "tuple4Make", "values", "tuple4ToString", "tuple", "lastValue", "tuple4Get", "V3_0_0", "tuple4Make", "V3_0_1", "V3_0_2", "V3_1_0", "V3_1_1", "V3_1_2", "V3_1_3", "V3_1_4", "V3_2_0", "V3_3_0", "V3_4_0", "V3_4_1", "V3_4_2", "V3_4_3", "V3_4_4", "V3_4_5", "V3_4_6", "V3_4_7", "V3_5_0", "VCurrent", "SeverityCodes", "SeverityFromCode", "code", "SeverityCodes", "normalizeLogEntry", "res", "uniqueId", "tuple4ToString", "VCurrent", "field", "length", "chars", "autoId", "i", "ConsoleLogStream", "severity", "SeverityFromCode", "e", "textLog", "kDefaultLoggerStreams", "ConsoleLogStream", "gLogStreams", "gLogLevel", "SeverityCodes", "log", "entry", "outputStreams", "gLogStreams", "SeverityCodes", "gLogLevel", "e", "normalizeLogEntry", "stream", "assert", "condition", "msg", "error", "log", "isWindows", "assertPath", "path", "stripSuffix", "name", "suffix", "lenDiff", "i", "lastPathSegment", "path", "isSep", "start", "matchedNonSeparator", "end", "assertArgs", "assertPath", "stripTrailingSeparators", "segment", "isSep", "end", "i", "isPosixPathSeparator", "code", "basename", "path", "suffix", "assertArgs", "lastSegment", "lastPathSegment", "isPosixPathSeparator", "strippedSegment", "stripTrailingSeparators", "stripSuffix", "isPosixPathSeparator", "code", "isPathSeparator", "isWindowsDeviceRoot", "basename", "path", "suffix", "assertArgs", "start", "drive", "isWindowsDeviceRoot", "lastSegment", "lastPathSegment", "isPathSeparator", "strippedSegment", "stripTrailingSeparators", "stripSuffix", "basename", "path", "suffix", "isWindows", "assertArg", "path", "assertPath", "dirname", "path", "assertArg", "end", "matchedNonSeparator", "i", "isPosixPathSeparator", "stripTrailingSeparators", "dirname", "path", "assertArg", "len", "rootEnd", "end", "matchedSlash", "offset", "code", "isPathSeparator", "j", "last", "isWindowsDeviceRoot", "stripTrailingSeparators", "isPosixPathSeparator", "dirname", "path", "isWindows", "assertArg", "path", "assertPath", "normalizeString", "path", "allowAboveRoot", "separator", "isPathSeparator", "res", "lastSegmentLength", "lastSlash", "dots", "code", "i", "lastSlashIndex", "normalize", "path", "assertArg", "isAbsolute", "isPosixPathSeparator", "trailingSeparator", "normalizeString", "normalize", "path", "assertArg", "len", "rootEnd", "device", "isAbsolute", "code", "isPathSeparator", "j", "last", "firstPart", "isWindowsDeviceRoot", "tail", "normalizeString", "normalize", "path", "isWindows", "FileImplDeno", "filePath", "write", "dirname", "handle", "offset", "from", "whence", "buf", "len", "bytesWritten", "arr", "getDir", "dirPath", "root", "normalize", "comps", "parent", "c", "FileImplOPFS", "filePath", "write", "handle", "dirname", "basename", "offset", "from", "buf", "readLen", "len", "bytesWritten", "arr", "FileImplGet", "FileImplOPFS", "FileImplDeno", "FILE_READ_BUF_SIZE_BYTES", "PAGE_SIZE", "LINE_DELIMITER_BYTE", "textDecoder", "JSONLogFileOpen", "path", "write", "impl", "FileImplGet", "JSONLogFileClose", "file", "JSONLogFileStartCursor", "totalFileBytes", "JSONLogFileScan", "cursor", "pendingObjects", "bytesRead", "readLen", "appendBytes", "text", "o", "JSONLogFileFlush", "src", "srcOffset", "srcLen", "dst", "dstOffset", "newDst", "JSONLogFileAppend", "entries", "assert", "filteredEntries", "e", "encodedEntries", "obj", "encodedBuf", "gOpenFiles", "gFileHandleNum", "gOpenCursors", "gOpenCursorNum", "readFile", "handle", "fileLen", "buf", "readTextFile", "writeFile", "writeTextFile", "encoder", "main", "event", "resp", "cursorId", "nextPromise", "entry", "values", "done"]
}
